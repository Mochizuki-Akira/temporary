<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>WebNotes MVP</title>
<style>
  :root { --bg:#111; --fg:#eee; --ui:#222; --acc:#4aa; }
  html,body { margin:0; height:100%; background:var(--bg); color:var(--fg); font-family: -apple-system, BlinkMacSystemFont, "Hiragino Sans", "Segoe UI", Roboto, "Noto Sans CJK", sans-serif; }
  .topbar{
    position:fixed; top:0; left:0; right:0; display:flex; gap:.5rem; align-items:center;
    padding:.5rem .75rem; background:rgba(20,20,20,.9); backdrop-filter: blur(8px); z-index:10; border-bottom:1px solid #333;
  }
  .btn, .seg > button {
    background:#1e1e1e; border:1px solid #333; color:#eee; border-radius:.5rem; padding:.5rem .75rem; cursor:pointer;
  }
  .seg{ display:flex; border-radius:.5rem; overflow:hidden; border:1px solid #333;}
  .seg > button { border:0; border-right:1px solid #333; }
  .seg > button:last-child{ border-right:0;}
  .btn.active{ outline:2px solid var(--acc); }
  .sp{ flex:1; }
  .range{ width:120px; }
  .board{
    position:fixed; top:52px; left:0; right:0; bottom:0; overflow:auto; display:flex; justify-content:center; padding:2rem 1rem 4rem;
  }
  .page{
    position:relative; width:900px; max-width:calc(100% - 2rem);
    background:#fff; box-shadow:0 10px 32px rgba(0,0,0,.35); margin-bottom:2rem; border-radius:6px;
    aspect-ratio: 1/1.4142; /* Aç³»åˆ—æ¯”ä¾‹ */
  }
  .bgimg{ position:absolute; inset:0; object-fit:contain; width:100%; height:100%; border-radius:6px; }
  canvas{ position:absolute; inset:0; touch-action:none; border-radius:6px; }
  .pager{
    position:fixed; right:1rem; bottom:1rem; display:flex; gap:.5rem; z-index:20;
  }
</style>
</head>
<body>
  <div class="topbar">
    <div class="seg" id="toolSeg">
      <button data-tool="pen" class="active">âœï¸ ç¬”</button>
      <button data-tool="eraser">ğŸ§½ æ©¡çš®</button>
      <button data-tool="pan">âœ‹ æ‹–åŠ¨</button>
    </div>
    <label>ç²—ç»† <input id="size" class="range" type="range" min="1" max="16" value="4"></label>
    <label>ä¸é€æ˜ <input id="alpha" class="range" type="range" min="0.1" max="1" step="0.05" value="1"></label>
    <button class="btn" id="undo">â†¶ æ’¤é”€</button>
    <button class="btn" id="redo">â†· é‡åš</button>
    <button class="btn" id="clear">æ¸…é¡µ</button>
    <div class="sp"></div>
    <input id="bgFile" type="file" accept="image/*" style="display:none">
    <button class="btn" id="bgBtn">è®¾èƒŒæ™¯å›¾</button>
    <button class="btn" id="save">ğŸ’¾ ä¿å­˜</button>
    <button class="btn" id="load">ğŸ“‚ è¯»å–</button>
    <button class="btn" id="export">â¬‡ï¸ å¯¼å‡ºPNG</button>
  </div>

  <div class="board" id="board"></div>

  <div class="pager">
    <button class="btn" id="addPage">â• æ–°é¡µ</button>
    <button class="btn" id="prevPage">â—€ï¸ ä¸Šä¸€é¡µ</button>
    <button class="btn" id="nextPage">ä¸‹ä¸€é¡µ â–¶ï¸</button>
    <span id="pageInfo" style="align-self:center"></span>
  </div>

<script>
/* --------- ç®€æ˜“æ•°æ®ç»“æ„ --------- */
const state = {
  pages: [],           // [{ strokes:[{pts:[{x,y,p}], size, alpha, color}], bgDataUrl }]
  pageIndex: 0,
  tool: 'pen',         // pen | eraser | pan
  size: 4,
  alpha: 1,
  color: '#000000',
  undoStacks: [],      // per page
  redoStacks: [],      // per page
};
const board = document.getElementById('board');
const pageInfo = document.getElementById('pageInfo');

/* --------- é¡µé¢ä¸ç”»å¸ƒ --------- */
function createPage(){ return { strokes:[], bgDataUrl: null }; }
function ensurePage(i){
  while(state.pages.length <= i){ state.pages.push(createPage()); state.undoStacks.push([]); state.redoStacks.push([]); }
}
function renderPage(){
  board.innerHTML = '';
  ensurePage(state.pageIndex);
  const page = state.pages[state.pageIndex];

  const pageEl = document.createElement('div');
  pageEl.className = 'page';

  const bg = document.createElement('img');
  bg.className = 'bgimg';
  if(page.bgDataUrl) bg.src = page.bgDataUrl;
  pageEl.appendChild(bg);

  const canvas = document.createElement('canvas');
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  // ä»¥ CSS åƒç´ å°ºå¯¸ä¸ºåŸºå‡†
  const rectObserver = new ResizeObserver(() => {
    const rect = pageEl.getBoundingClientRect();
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    drawAll();
  });
  rectObserver.observe(pageEl);
  pageEl.appendChild(canvas);

  board.appendChild(pageEl);

  const ctx = canvas.getContext('2d');
  ctx.lineCap = 'round'; ctx.lineJoin='round';

  function drawAll(){
    const rect = pageEl.getBoundingClientRect();
    const scale = (canvas.width / rect.width);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    for(const s of page.strokes){
      ctx.globalCompositeOperation = s.erase ? 'destination-out' : 'source-over';
      ctx.strokeStyle = s.color || '#000';
      ctx.lineWidth = s.size * scale;
      ctx.globalAlpha = s.alpha ?? 1;
      ctx.beginPath();
      s.pts.forEach((pt,i)=>{
        const x = pt.x*scale, y = pt.y*scale;
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      });
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = 'source-over';
  }

  // äº¤äº’
  let drawing = false;
  let curStroke = null;
  let lastPan = null;

  const getRel = (e)=>{
    const r = canvas.getBoundingClientRect();
    const x = (e.clientX - r.left);
    const y = (e.clientY - r.top);
    // è®°å½•ä¸º CSS åƒç´ åæ ‡ï¼Œç¼©æ”¾æ—¶å†æ¢ç®—
    const pressure = e.pressure || 0.5;
    return {x, y, p: pressure};
  };

  canvas.addEventListener('pointerdown', e=>{
    canvas.setPointerCapture(e.pointerId);
    if(state.tool === 'pan'){ lastPan = {x:e.clientX, y:e.clientY, sx: board.scrollLeft, sy: board.scrollTop}; return; }

    drawing = true;
    curStroke = {
      pts: [getRel(e)],
      size: state.tool==='pen' ? sizeWithPressure(state.size, e.pressure) : state.size * 2.2,
      alpha: state.alpha,
      color: state.tool==='eraser' ? '#000' : state.color,
      erase: state.tool==='eraser'
    };
    page.strokes.push(curStroke);
    state.redoStacks[state.pageIndex] = []; // æ–°æ“ä½œæ¸…ç©ºé‡åšæ ˆ
    drawAll();
  });

  canvas.addEventListener('pointermove', e=>{
    if(state.tool === 'pan' && lastPan){
      const dx = e.clientX - lastPan.x, dy = e.clientY - lastPan.y;
      board.scrollLeft = lastPan.sx - dx;
      board.scrollTop = lastPan.sy - dy;
      return;
    }
    if(!drawing) return;
    curStroke.pts.push(getRel(e));
    // åŠ¨æ€æ›´æ–°å½“å‰çº¿å®½ä»¥ä½“ç°å‹æ„Ÿ
    curStroke.size = state.tool==='pen' ? sizeWithPressure(state.size, e.pressure) : state.size * 2.2;
    drawAll();
  });

  window.addEventListener('pointerup', e=>{
    if(state.tool==='pan'){ lastPan=null; return; }
    if(!drawing) return;
    drawing=false;
    // è®°å½•åˆ°æ’¤é”€æ ˆ
    state.undoStacks[state.pageIndex].push({ type:'add', stroke: curStroke });
    curStroke = null;
  });

  function sizeWithPressure(base, p){
    if(!p || p<=0) p=0.5;
    // ç®€å•å‹æ„Ÿæ˜ å°„ï¼š0.7~1.3å€
    return base * (0.7 + 0.6 * p);
  }

  // å¯¼å‡ºéœ€è¦
  pageEl._canvas = canvas;
  pageEl._drawAll = drawAll;

  updatePageInfo();
}
function updatePageInfo(){
  pageInfo.textContent = `ç¬¬ ${state.pageIndex+1} / ${state.pages.length} é¡µ`;
}

/* --------- åŸºæœ¬æ“ä½œ --------- */
function setTool(t){
  state.tool = t;
  document.querySelectorAll('#toolSeg button').forEach(b=>{
    b.classList.toggle('active', b.dataset.tool===t);
  });
}
document.getElementById('toolSeg').addEventListener('click', e=>{
  if(e.target.tagName==='BUTTON') setTool(e.target.dataset.tool);
});
document.getElementById('size').addEventListener('input', e=> state.size = +e.target.value);
document.getElementById('alpha').addEventListener('input', e=> state.alpha = +e.target.value);

document.getElementById('undo').onclick = ()=>{
  const stack = state.undoStacks[state.pageIndex];
  const page = state.pages[state.pageIndex];
  if(!stack || !stack.length) return;
  const op = stack.pop();
  if(op.type==='add'){
    page.strokes.pop();
    state.redoStacks[state.pageIndex].push(op);
  }
  document.querySelector('.page')._drawAll();
};
document.getElementById('redo').onclick = ()=>{
  const stack = state.redoStacks[state.pageIndex];
  const page = state.pages[state.pageIndex];
  if(!stack || !stack.length) return;
  const op = stack.pop();
  if(op.type==='add'){
    page.strokes.push(op.stroke);
    state.undoStacks[state.pageIndex].push(op);
  }
  document.querySelector('.page')._drawAll();
};
document.getElementById('clear').onclick = ()=>{
  const page = state.pages[state.pageIndex];
  if(!page.strokes.length) return;
  state.undoStacks[state.pageIndex].push({type:'bulk', prev:[...page.strokes]});
  page.strokes = [];
  state.redoStacks[state.pageIndex] = [];
  document.querySelector('.page')._drawAll();
};

document.getElementById('addPage').onclick = ()=>{
  ensurePage(state.pages.length);
  state.pageIndex = state.pages.length - 1;
  renderPage();
};
document.getElementById('prevPage').onclick = ()=>{
  state.pageIndex = Math.max(0, state.pageIndex - 1);
  renderPage();
};
document.getElementById('nextPage').onclick = ()=>{
  state.pageIndex = Math.min(state.pages.length - 1, state.pageIndex + 1);
  renderPage();
};

document.getElementById('bgBtn').onclick = ()=> document.getElementById('bgFile').click();
document.getElementById('bgFile').addEventListener('change', async (e)=>{
  const file = e.target.files[0]; if(!file) return;
  const url = await fileToDataURL(file);
  state.pages[state.pageIndex].bgDataUrl = url;
  renderPage();
});
function fileToDataURL(f){ return new Promise(res=>{ const r=new FileReader(); r.onload=()=>res(r.result); r.readAsDataURL(f); }); }

/* --------- å­˜å–ä¸å¯¼å‡º --------- */
document.getElementById('save').onclick = ()=>{
  localStorage.setItem('webnotes_v1', JSON.stringify(state.pages));
  alert('å·²ä¿å­˜åˆ°æœ¬åœ°ï¼ˆlocalStorageï¼‰');
};
document.getElementById('load').onclick = ()=>{
  const raw = localStorage.getItem('webnotes_v1');
  if(!raw) return alert('æ²¡æœ‰æ‰¾åˆ°ä¿å­˜çš„æ•°æ®');
  try{
    const pages = JSON.parse(raw);
    if(Array.isArray(pages) && pages.length){
      state.pages = pages;
      state.pageIndex = 0;
      state.undoStacks = pages.map(()=>[]);
      state.redoStacks = pages.map(()=>[]);
      renderPage();
    }
  }catch(e){ alert('è¯»å–å¤±è´¥'); }
};
document.getElementById('export').onclick = ()=>{
  const pageEl = document.querySelector('.page');
  // ç›´æ¥å–ç»˜åˆ¶åçš„å‰æ™¯ Canvas å¯¼å‡ºï¼ˆè‹¥éœ€è¦åŒ…å«èƒŒæ™¯ï¼Œå¯å…ˆåˆæˆï¼‰
  const c = document.createElement('canvas');
  const dpr = window.devicePixelRatio || 1;
  const rect = pageEl.getBoundingClientRect();
  c.width = rect.width * dpr; c.height = rect.height * dpr;
  const ctx = c.getContext('2d');
  // èƒŒæ™¯
  if(state.pages[state.pageIndex].bgDataUrl){
    const img = new Image();
    img.onload = ()=>{ ctx.drawImage(img,0,0,c.width,c.height); drawStrokesAndSave(); };
    img.src = state.pages[state.pageIndex].bgDataUrl;
  } else {
    ctx.fillStyle='#fff'; ctx.fillRect(0,0,c.width,c.height);
    drawStrokesAndSave();
  }
  function drawStrokesAndSave(){
    // é‡æ–°ç»˜åˆ¶å…¨éƒ¨ç¬”è¿¹
    const page = state.pages[state.pageIndex];
    for(const s of page.strokes){
      ctx.globalCompositeOperation = s.erase ? 'destination-out' : 'source-over';
      ctx.strokeStyle = s.color || '#000';
      ctx.lineWidth = s.size;
      ctx.globalAlpha = s.alpha ?? 1;
      ctx.beginPath();
      s.pts.forEach((pt,i)=>{
        const x = pt.x * (c.width / rect.width);
        const y = pt.y * (c.height / rect.height);
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      });
      ctx.stroke();
    }
    ctx.globalAlpha = 1; ctx.globalCompositeOperation = 'source-over';
    const url = c.toDataURL('image/png');
    const a = document.createElement('a');
    a.href = url; a.download = `page-${state.pageIndex+1}.png`;
    a.click();
  }
};

/* --------- åˆå§‹åŒ– --------- */
ensurePage(0);
renderPage();
</script>
</body>
</html>
